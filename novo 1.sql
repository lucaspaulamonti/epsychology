CREATE TABLE METADATA (
	ID INTEGER,
	SCHEMA VARCHAR(65),
	COMMENT VARCHAR(255),

	CONSTRAINT PK_METADATA__ID PRIMARY KEY (ID),
	CONSTRAINT UQ_METADATA__SCHEMA UNIQUE (SCHEMA),
	CONSTRAINT NN_METADATA__SCHEMA CHECK (SCHEMA IS NOT NULL)
);

CREATE SEQUENCE SQ_METADATA__ID;

CREATE OR REPLACE FUNCTION BI_METADATA__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_METADATA__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_METADATA__ID
BEFORE INSERT ON METADATA
FOR EACH ROW
EXECUTE FUNCTION BI_METADATA__ID();


CREATE TABLE BIOLOGICALSEX (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_BIOLOGICALSEX__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_BIOLOGICALSEX__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_BIOLOGICALSEX__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_BIOLOGICALSEX__ID;

CREATE OR REPLACE FUNCTION BI_BIOLOGICALSEX__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_BIOLOGICALSEX__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_BIOLOGICALSEX__ID
BEFORE INSERT ON BIOLOGICALSEX
FOR EACH ROW
EXECUTE FUNCTION BI_BIOLOGICALSEX__ID();

INSERT INTO BIOLOGICALSEX (DESCRIPTION) VALUES ('MASCULINO');
INSERT INTO BIOLOGICALSEX (DESCRIPTION) VALUES ('FEMININO');
INSERT INTO BIOLOGICALSEX (DESCRIPTION) VALUES ('INTERSEXO');

CREATE TABLE SEXUALORIENTATION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_SEXUALORIENTATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_SEXUALORIENTATION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_SEXUALORIENTATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_SEXUALORIENTATION__ID;

CREATE OR REPLACE FUNCTION BI_SEXUALORIENTATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_SEXUALORIENTATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_SEXUALORIENTATION__ID
BEFORE INSERT ON SEXUALORIENTATION
FOR EACH ROW
EXECUTE FUNCTION BI_SEXUALORIENTATION__ID();


CREATE TABLE GENDEREXPRESSION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_GENDEREXPRESSION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_GENDEREXPRESSION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_GENDEREXPRESSION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_GENDEREXPRESSION__ID;

CREATE OR REPLACE FUNCTION BI_GENDEREXPRESSION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_GENDEREXPRESSION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_GENDEREXPRESSION__ID
BEFORE INSERT ON GENDEREXPRESSION
FOR EACH ROW
EXECUTE FUNCTION BI_GENDEREXPRESSION__ID();

INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('MASCULINA');
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('FEMININA');
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('ANDROGINA');
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('FLUIDA');
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('NAO BINARIA');

CREATE TABLE GENDERIDENTITY (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_GENDERIDENTITY__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_GENDERIDENTITY__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_GENDERIDENTITY__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_GENDERIDENTITY__ID;

CREATE OR REPLACE FUNCTION BI_GENDERIDENTITY__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_GENDERIDENTITY__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_GENDERIDENTITY__ID
BEFORE INSERT ON GENDERIDENTITY
FOR EACH ROW
EXECUTE FUNCTION BI_GENDERIDENTITY__ID();


CREATE TABLE MARITALSTATUS (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_MARITALSTATUS__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_MARITALSTATUS__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_MARITALSTATUS__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_MARITALSTATUS__ID;

CREATE OR REPLACE FUNCTION BI_MARITALSTATUS__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_MARITALSTATUS__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_MARITALSTATUS__ID
BEFORE INSERT ON MARITALSTATUS
FOR EACH ROW
EXECUTE FUNCTION BI_MARITALSTATUS__ID();


CREATE TABLE RELIGIOUSAFFILIATION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_RELIGIOUSAFFILIATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_RELIGIOUSAFFILIATION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_RELIGIOUSAFFILIATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_RELIGIOUSAFFILIATION__ID;

CREATE OR REPLACE FUNCTION BI_RELIGIOUSAFFILIATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_RELIGIOUSAFFILIATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_RELIGIOUSAFFILIATION__ID
BEFORE INSERT ON RELIGIOUSAFFILIATION
FOR EACH ROW
EXECUTE FUNCTION BI_RELIGIOUSAFFILIATION__ID();


CREATE TABLE JOBOCCUPATION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_JOBOCCUPATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_JOBOCCUPATION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_JOBOCCUPATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_JOBOCCUPATION__ID;

CREATE OR REPLACE FUNCTION BI_JOBOCCUPATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_JOBOCCUPATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_JOBOCCUPATION__ID
BEFORE INSERT ON JOBOCCUPATION
FOR EACH ROW
EXECUTE FUNCTION BI_JOBOCCUPATION__ID();


CREATE TABLE ETHNICGROUP (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_ETHNICGROUP__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_ETHNICGROUP__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_ETHNICGROUP__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_ETHNICGROUP__ID;

CREATE OR REPLACE FUNCTION BI_ETHNICGROUP__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_ETHNICGROUP__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_ETHNICGROUP__ID
BEFORE INSERT ON ETHNICGROUP
FOR EACH ROW
EXECUTE FUNCTION BI_ETHNICGROUP__ID();


CREATE TABLE COUNTRYGEOGRAPHIC (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_COUNTRYGEOGRAPHIC__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_COUNTRYGEOGRAPHIC__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_COUNTRYGEOGRAPHIC__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_COUNTRYGEOGRAPHIC__ID;

CREATE OR REPLACE FUNCTION BI_COUNTRYGEOGRAPHIC__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_COUNTRYGEOGRAPHIC__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_COUNTRYGEOGRAPHIC__ID
BEFORE INSERT ON COUNTRYGEOGRAPHIC
FOR EACH ROW
EXECUTE FUNCTION BI_COUNTRYGEOGRAPHIC__ID();


CREATE TABLE STATEGEOGRAPHIC (
	ID INTEGER,
	ID_COUNTRY INTEGER,
	DESCRIPTION VARCHAR(75),

	CONSTRAINT PK_STATEGEOGRAPHIC__ID PRIMARY KEY (ID),
	CONSTRAINT FK_STATEGEOGRAPHIC_COUNTRY__ID_COUNTRY FOREIGN KEY (ID_COUNTRY) REFERENCES COUNTRYGEOGRAPHIC (ID),
	CONSTRAINT NN_STATEGEOGRAPHIC__ID_COUNTRY CHECK (ID_COUNTRY IS NOT NULL),
	CONSTRAINT NN_STATEGEOGRAPHIC__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_STATEGEOGRAPHIC__ID;

CREATE OR REPLACE FUNCTION BI_STATEGEOGRAPHIC__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_STATEGEOGRAPHIC__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_STATEGEOGRAPHIC__ID
BEFORE INSERT ON STATEGEOGRAPHIC
FOR EACH ROW
EXECUTE FUNCTION BI_STATEGEOGRAPHIC__ID();


CREATE TABLE CITYGEOGRAPHIC (
	ID INTEGER,
	ID_STATE INTEGER,
	DESCRIPTION VARCHAR(75),

	CONSTRAINT PK_CITYGEOGRAPHIC__ID PRIMARY KEY (ID),
	CONSTRAINT FK_CITYGEOGRAPHIC_STATE__ID_STATE FOREIGN KEY (ID_STATE) REFERENCES STATEGEOGRAPHIC (ID),
	CONSTRAINT NN_CITYGEOGRAPHIC__ID_STATE CHECK (ID_STATE IS NOT NULL),
	CONSTRAINT NN_CITYGEOGRAPHIC__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_CITYGEOGRAPHIC__ID;

CREATE OR REPLACE FUNCTION BI_CITYGEOGRAPHIC__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_CITYGEOGRAPHIC__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_CITYGEOGRAPHIC__ID
BEFORE INSERT ON CITYGEOGRAPHIC
FOR EACH ROW
EXECUTE FUNCTION BI_CITYGEOGRAPHIC__ID();


CREATE TABLE ACADEMICDEGREE (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_ACADEMICDEGREE__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_ACADEMICDEGREE__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_ACADEMICDEGREE__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_ACADEMICDEGREE__ID;

CREATE OR REPLACE FUNCTION BI_ACADEMICDEGREE__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_ACADEMICDEGREE__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_ACADEMICDEGREE__ID
BEFORE INSERT ON ACADEMICDEGREE
FOR EACH ROW
EXECUTE FUNCTION BI_ACADEMICDEGREE__ID();


CREATE TABLE MONTHLYINCOME (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_MONTHLYINCOME__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_MONTHLYINCOME__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_MONTHLYINCOME__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_MONTHLYINCOME__ID;

CREATE OR REPLACE FUNCTION BI_MONTHLYINCOME__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_MONTHLYINCOME__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_MONTHLYINCOME__ID
BEFORE INSERT ON MONTHLYINCOME
FOR EACH ROW
EXECUTE FUNCTION BI_MONTHLYINCOME__ID();


CREATE TABLE REGISTRATIONSTATUS (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_REGISTRATIONSTATUS__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_REGISTRATIONSTATUS__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_REGISTRATIONSTATUS__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_REGISTRATIONSTATUS__ID;

CREATE OR REPLACE FUNCTION BI_REGISTRATIONSTATUS__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_REGISTRATIONSTATUS__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_REGISTRATIONSTATUS__ID
BEFORE INSERT ON REGISTRATIONSTATUS
FOR EACH ROW
EXECUTE FUNCTION BI_REGISTRATIONSTATUS__ID();


CREATE TABLE MEDICALINSURANCE (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_MEDICALINSURANCE__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_MEDICALINSURANCE__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_MEDICALINSURANCE__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_MEDICALINSURANCE__ID;

CREATE OR REPLACE FUNCTION BI_MEDICALINSURANCE__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_MEDICALINSURANCE__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_MEDICALINSURANCE__ID
BEFORE INSERT ON MEDICALINSURANCE
FOR EACH ROW
EXECUTE FUNCTION BI_MEDICALINSURANCE__ID();


CREATE TABLE BLOODTYPE (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_BLOODTYPE__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_BLOODTYPE__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_BLOODTYPE__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_BLOODTYPE__ID;

CREATE OR REPLACE FUNCTION BI_BLOODTYPE__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_BLOODTYPE__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_BLOODTYPE__ID
BEFORE INSERT ON BLOODTYPE
FOR EACH ROW
EXECUTE FUNCTION BI_BLOODTYPE__ID();


CREATE TABLE DISABILITYPERSON (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_DISABILITYPERSON__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_DISABILITYPERSON__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_DISABILITYPERSON__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE SQ_DISABILITYPERSON__ID;

CREATE OR REPLACE FUNCTION BI_DISABILITYPERSON__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_DISABILITYPERSON__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER BI_DISABILITYPERSON__ID
BEFORE INSERT ON DISABILITYPERSON
FOR EACH ROW
EXECUTE FUNCTION BI_DISABILITYPERSON__ID();
