CREATE TABLE IF NOT EXISTS METADATAMANAGEMENT (
	ID INTEGER,
	SCHEMA VARCHAR(65),
	COMMENT VARCHAR(255),

	CONSTRAINT PK_METADATAMANAGEMENT__ID PRIMARY KEY (ID),
	CONSTRAINT UQ_METADATAMANAGEMENT__SCHEMA UNIQUE (SCHEMA),
	CONSTRAINT NN_METADATAMANAGEMENT__SCHEMA CHECK (SCHEMA IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_METADATAMANAGEMENT__ID;

ALTER SEQUENCE SQ_METADATAMANAGEMENT__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_METADATAMANAGEMENT__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_METADATAMANAGEMENT__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_METADATAMANAGEMENT__ID
BEFORE INSERT ON METADATAMANAGEMENT
FOR EACH ROW
EXECUTE FUNCTION BI_METADATAMANAGEMENT__ID();

CREATE TABLE IF NOT EXISTS BIOLOGICALSEX (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_BIOLOGICALSEX__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_BIOLOGICALSEX__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_BIOLOGICALSEX__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_BIOLOGICALSEX__ID;

ALTER SEQUENCE SQ_BIOLOGICALSEX__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_BIOLOGICALSEX__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_BIOLOGICALSEX__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_BIOLOGICALSEX__ID
BEFORE INSERT ON BIOLOGICALSEX
FOR EACH ROW
EXECUTE FUNCTION BI_BIOLOGICALSEX__ID();

INSERT INTO BIOLOGICALSEX (DESCRIPTION) VALUES ('MASCULINO') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO BIOLOGICALSEX (DESCRIPTION) VALUES ('FEMININO') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO BIOLOGICALSEX (DESCRIPTION) VALUES ('INTERSEXO') 
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS SEXUALORIENTATION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_SEXUALORIENTATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_SEXUALORIENTATION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_SEXUALORIENTATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_SEXUALORIENTATION__ID;

ALTER SEQUENCE SQ_SEXUALORIENTATION__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_SEXUALORIENTATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_SEXUALORIENTATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_SEXUALORIENTATION__ID
BEFORE INSERT ON SEXUALORIENTATION
FOR EACH ROW
EXECUTE FUNCTION BI_SEXUALORIENTATION__ID();

INSERT INTO SEXUALORIENTATION (DESCRIPTION) VALUES ('HETEROSSEXUAL')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO SEXUALORIENTATION (DESCRIPTION) VALUES ('HOMOSSEXUAL')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO SEXUALORIENTATION (DESCRIPTION) VALUES ('BISSEXUAL')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO SEXUALORIENTATION (DESCRIPTION) VALUES ('ASSEXUAL')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO SEXUALORIENTATION (DESCRIPTION) VALUES ('PANSEXUAL')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS GENDEREXPRESSION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_GENDEREXPRESSION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_GENDEREXPRESSION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_GENDEREXPRESSION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_GENDEREXPRESSION__ID;

ALTER SEQUENCE SQ_GENDEREXPRESSION__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_GENDEREXPRESSION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_GENDEREXPRESSION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_GENDEREXPRESSION__ID
BEFORE INSERT ON GENDEREXPRESSION
FOR EACH ROW
EXECUTE FUNCTION BI_GENDEREXPRESSION__ID();

INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('MASCULINA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('FEMININA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('ANDROGINA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('FLUIDA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO GENDEREXPRESSION (DESCRIPTION) VALUES ('NAO BINARIA')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS GENDERIDENTITY (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_GENDERIDENTITY__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_GENDERIDENTITY__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_GENDERIDENTITY__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_GENDERIDENTITY__ID;

ALTER SEQUENCE SQ_GENDERIDENTITY__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_GENDERIDENTITY__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_GENDERIDENTITY__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_GENDERIDENTITY__ID
BEFORE INSERT ON GENDERIDENTITY
FOR EACH ROW
EXECUTE FUNCTION BI_GENDERIDENTITY__ID();

INSERT INTO GENDERIDENTITY (DESCRIPTION) VALUES ('CISGENERO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO GENDERIDENTITY (DESCRIPTION) VALUES ('TRANSGENERO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO GENDERIDENTITY (DESCRIPTION) VALUES ('INTERSEXUAL')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS MARITALSTATUS (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_MARITALSTATUS__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_MARITALSTATUS__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_MARITALSTATUS__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_MARITALSTATUS__ID;

ALTER SEQUENCE SQ_MARITALSTATUS__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_MARITALSTATUS__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_MARITALSTATUS__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_MARITALSTATUS__ID
BEFORE INSERT ON MARITALSTATUS
FOR EACH ROW
EXECUTE FUNCTION BI_MARITALSTATUS__ID();

INSERT INTO MARITALSTATUS (DESCRIPTION) VALUES ('SOLTEIRO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MARITALSTATUS (DESCRIPTION) VALUES ('CASADO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MARITALSTATUS (DESCRIPTION) VALUES ('SEPARADO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MARITALSTATUS (DESCRIPTION) VALUES ('DIVORCIADO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MARITALSTATUS (DESCRIPTION) VALUES ('VIUVO')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS RELIGIOUSAFFILIATION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_RELIGIOUSAFFILIATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_RELIGIOUSAFFILIATION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_RELIGIOUSAFFILIATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_RELIGIOUSAFFILIATION__ID;

ALTER SEQUENCE SQ_RELIGIOUSAFFILIATION__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_RELIGIOUSAFFILIATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_RELIGIOUSAFFILIATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_RELIGIOUSAFFILIATION__ID
BEFORE INSERT ON RELIGIOUSAFFILIATION
FOR EACH ROW
EXECUTE FUNCTION BI_RELIGIOUSAFFILIATION__ID();

INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('CRISTIANISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('CATOLICISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('PROTESTANTISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('ADVENTISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('ANGLICANISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('TESTEMUNHA DE JEOVA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('MORMONISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('IGREJA ORTODOXA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('ESPIRITISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('ISLAMISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('JUDAISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('NEOPAGANISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('HINDUISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('SANTO DAIME')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('CANDOMBLE')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('UMBANDA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('AGNOSTICISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('ATEISMO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO RELIGIOUSAFFILIATION (DESCRIPTION) VALUES ('SEM RELIGIAO')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS JOBOCCUPATION (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_JOBOCCUPATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_JOBOCCUPATION__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_JOBOCCUPATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_JOBOCCUPATION__ID;

ALTER SEQUENCE SQ_JOBOCCUPATION__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_JOBOCCUPATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_JOBOCCUPATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_JOBOCCUPATION__ID
BEFORE INSERT ON JOBOCCUPATION
FOR EACH ROW
EXECUTE FUNCTION BI_JOBOCCUPATION__ID();

INSERT INTO JOBOCCUPATION (DESCRIPTION) VALUES ('DESEMPREGADO')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS ETHNICGROUP (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_ETHNICGROUP__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_ETHNICGROUP__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_ETHNICGROUP__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_ETHNICGROUP__ID;

ALTER SEQUENCE SQ_ETHNICGROUP__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_ETHNICGROUP__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_ETHNICGROUP__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_ETHNICGROUP__ID
BEFORE INSERT ON ETHNICGROUP
FOR EACH ROW
EXECUTE FUNCTION BI_ETHNICGROUP__ID();

INSERT INTO ETHNICGROUP (DESCRIPTION) VALUES ('BRANCO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ETHNICGROUP (DESCRIPTION) VALUES ('PARDO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ETHNICGROUP (DESCRIPTION) VALUES ('NEGRO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ETHNICGROUP (DESCRIPTION) VALUES ('INDIGENA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ETHNICGROUP (DESCRIPTION) VALUES ('AMARELO')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS COUNTRYGEOGRAPHIC (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_COUNTRYGEOGRAPHIC__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_COUNTRYGEOGRAPHIC__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_COUNTRYGEOGRAPHIC__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_COUNTRYGEOGRAPHIC__ID;

ALTER SEQUENCE SQ_COUNTRYGEOGRAPHIC__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_COUNTRYGEOGRAPHIC__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_COUNTRYGEOGRAPHIC__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_COUNTRYGEOGRAPHIC__ID
BEFORE INSERT ON COUNTRYGEOGRAPHIC
FOR EACH ROW
EXECUTE FUNCTION BI_COUNTRYGEOGRAPHIC__ID();

INSERT INTO COUNTRYGEOGRAPHIC (DESCRIPTION) VALUES ('BRASIL')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS STATEGEOGRAPHIC (
	ID INTEGER,
	ID_COUNTRY INTEGER,
	DESCRIPTION VARCHAR(75),

	CONSTRAINT PK_STATEGEOGRAPHIC__ID PRIMARY KEY (ID),
	CONSTRAINT FK_STATEGEOGRAPHIC_COUNTRY__ID_COUNTRY FOREIGN KEY (ID_COUNTRY) REFERENCES COUNTRYGEOGRAPHIC (ID),
	CONSTRAINT NN_STATEGEOGRAPHIC__ID_COUNTRY CHECK (ID_COUNTRY IS NOT NULL),
	CONSTRAINT NN_STATEGEOGRAPHIC__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_STATEGEOGRAPHIC__ID;

ALTER SEQUENCE SQ_STATEGEOGRAPHIC__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_STATEGEOGRAPHIC__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_STATEGEOGRAPHIC__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_STATEGEOGRAPHIC__ID
BEFORE INSERT ON STATEGEOGRAPHIC
FOR EACH ROW
EXECUTE FUNCTION BI_STATEGEOGRAPHIC__ID();

/* atencao corrigir essa gambiarra depois*/
DELETE FROM CITYGEOGRAPHIC;
DELETE FROM STATEGEOGRAPHIC;

INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('ACRE', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('ALAGOAS', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('AMAPA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('AMAZONAS', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('BAHIA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('CEARA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('ESPIRITO SANTO', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('GOIAS', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('MARANHAO', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('MATO GROSSO', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('MATO GROSSO DO SUL', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('MINAS GERAIS', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('PARA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('PARAIBA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('PARANA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('PERNAMBUCO', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('PIAUI', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('RIO DE JANEIRO', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('RIO GRANDE DO NORTE', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('RIO GRANDE DO SUL', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('RONDONIA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('RORAIMA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('SANTA CATARINA', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('SAO PAULO', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('SERGIPE', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('TOCANTINS', 1);
INSERT INTO STATEGEOGRAPHIC (DESCRIPTION, ID_COUNTRY) VALUES ('DISTRITO FEDERAL', 1);

CREATE TABLE IF NOT EXISTS CITYGEOGRAPHIC (
	ID INTEGER,
	ID_STATE INTEGER,
	DESCRIPTION VARCHAR(75),

	CONSTRAINT PK_CITYGEOGRAPHIC__ID PRIMARY KEY (ID),
	CONSTRAINT FK_CITYGEOGRAPHIC_STATE__ID_STATE FOREIGN KEY (ID_STATE) REFERENCES STATEGEOGRAPHIC (ID),
	CONSTRAINT NN_CITYGEOGRAPHIC__ID_STATE CHECK (ID_STATE IS NOT NULL),
	CONSTRAINT NN_CITYGEOGRAPHIC__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_CITYGEOGRAPHIC__ID;

ALTER SEQUENCE SQ_CITYGEOGRAPHIC__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_CITYGEOGRAPHIC__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_CITYGEOGRAPHIC__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_CITYGEOGRAPHIC__ID
BEFORE INSERT ON CITYGEOGRAPHIC
FOR EACH ROW
EXECUTE FUNCTION BI_CITYGEOGRAPHIC__ID();

INSERT INTO CITYGEOGRAPHIC (DESCRIPTION, ID_STATE) VALUES ('ACARATUBA', 24);
INSERT INTO CITYGEOGRAPHIC (DESCRIPTION, ID_STATE) VALUES ('BIRIGUI', 24);
INSERT INTO CITYGEOGRAPHIC (DESCRIPTION, ID_STATE) VALUES ('GUARARAPES', 24);

CREATE TABLE IF NOT EXISTS ACADEMICDEGREE (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_ACADEMICDEGREE__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_ACADEMICDEGREE__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_ACADEMICDEGREE__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_ACADEMICDEGREE__ID;

ALTER SEQUENCE SQ_ACADEMICDEGREE__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_ACADEMICDEGREE__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_ACADEMICDEGREE__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_ACADEMICDEGREE__ID
BEFORE INSERT ON ACADEMICDEGREE
FOR EACH ROW
EXECUTE FUNCTION BI_ACADEMICDEGREE__ID();

INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('ANALFABETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('FUNDAMENTAL INCOMPLETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('FUNDAMENTAL COMPLETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('MEDIO INCOMPLETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('MEDIO COMPLETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('SUPERIOR INCOMPLETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('SUPERIOR COMPLETO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO ACADEMICDEGREE (DESCRIPTION) VALUES ('POS-GRADUADO')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS MONTHLYINCOME (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_MONTHLYINCOME__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_MONTHLYINCOME__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_MONTHLYINCOME__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_MONTHLYINCOME__ID;

ALTER SEQUENCE SQ_MONTHLYINCOME__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_MONTHLYINCOME__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_MONTHLYINCOME__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_MONTHLYINCOME__ID
BEFORE INSERT ON MONTHLYINCOME
FOR EACH ROW
EXECUTE FUNCTION BI_MONTHLYINCOME__ID();

INSERT INTO MONTHLYINCOME (DESCRIPTION) VALUES ('ATE 1 SALARIO MINIMO (BAIXA RENDA)')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MONTHLYINCOME (DESCRIPTION) VALUES ('DE 1 A 2 SALARIOS MINIMOS (MEDIA-BAIXA RENDA)')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MONTHLYINCOME (DESCRIPTION) VALUES ('DE 2 A 5 SALARIOS MINIMOS (MEDIA RENDA)')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MONTHLYINCOME (DESCRIPTION) VALUES ('DE 5 A 10 SALARIOS MINIMOS (MEDIA-ALTA RENDA)')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MONTHLYINCOME (DESCRIPTION) VALUES ('ACIMA DE 10 SALARIOS MINIMOS (ALTA RENDA)')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS REGISTRATIONSTATUS (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_REGISTRATIONSTATUS__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_REGISTRATIONSTATUS__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_REGISTRATIONSTATUS__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_REGISTRATIONSTATUS__ID;

ALTER SEQUENCE SQ_REGISTRATIONSTATUS__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_REGISTRATIONSTATUS__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_REGISTRATIONSTATUS__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_REGISTRATIONSTATUS__ID
BEFORE INSERT ON REGISTRATIONSTATUS
FOR EACH ROW
EXECUTE FUNCTION BI_REGISTRATIONSTATUS__ID();

INSERT INTO REGISTRATIONSTATUS (DESCRIPTION) VALUES ('ATIVO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO REGISTRATIONSTATUS (DESCRIPTION) VALUES ('INATIVO')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO REGISTRATIONSTATUS (DESCRIPTION) VALUES ('PENDENCIA FINANCEIRA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO REGISTRATIONSTATUS (DESCRIPTION) VALUES ('PENDENCIA ADMINISTRATIVA')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS MEDICALINSURANCE (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_MEDICALINSURANCE__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_MEDICALINSURANCE__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_MEDICALINSURANCE__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_MEDICALINSURANCE__ID;

ALTER SEQUENCE SQ_MEDICALINSURANCE__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_MEDICALINSURANCE__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_MEDICALINSURANCE__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_MEDICALINSURANCE__ID
BEFORE INSERT ON MEDICALINSURANCE
FOR EACH ROW
EXECUTE FUNCTION BI_MEDICALINSURANCE__ID();

INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('BRADESCO SAUDE')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('SULAMERICA SAUDE')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('NOTREDAME INTERMEDICA') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('AMIL') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('UNIMED') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('ALICE') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('MEDSENIOR') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('PROASA SAUDE') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('PORTO SEGURO SAUDE') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('VERA CRUZ') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('ALBERT EINSTEIN') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('OSWALDO CRUZ') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO MEDICALINSURANCE (DESCRIPTION) VALUES ('CASSI') 
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS BLOODTYPE (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_BLOODTYPE__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_BLOODTYPE__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_BLOODTYPE__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_BLOODTYPE__ID;

ALTER SEQUENCE SQ_BLOODTYPE__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_BLOODTYPE__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_BLOODTYPE__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_BLOODTYPE__ID
BEFORE INSERT ON BLOODTYPE
FOR EACH ROW
EXECUTE FUNCTION BI_BLOODTYPE__ID();

CREATE TABLE IF NOT EXISTS DISABILITYPERSON (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_DISABILITYPERSON__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_DISABILITYPERSON__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_DISABILITYPERSON__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_DISABILITYPERSON__ID;

ALTER SEQUENCE SQ_DISABILITYPERSON__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_DISABILITYPERSON__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_DISABILITYPERSON__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_DISABILITYPERSON__ID
BEFORE INSERT ON DISABILITYPERSON
FOR EACH ROW
EXECUTE FUNCTION BI_DISABILITYPERSON__ID();

INSERT INTO DISABILITYPERSON (DESCRIPTION) VALUES ('DEFICIENCIA FISICA') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO DISABILITYPERSON (DESCRIPTION) VALUES ('DEFICIENCIA VISUAL') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO DISABILITYPERSON (DESCRIPTION) VALUES ('DEFICIENCIA AUDITIVA') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO DISABILITYPERSON (DESCRIPTION) VALUES ('DEFICIENCIA INTELECTUAL') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO DISABILITYPERSON (DESCRIPTION) VALUES ('DEFICIENCIA PSICOSSOCIAL') 
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO DISABILITYPERSON (DESCRIPTION) VALUES ('DEFICIENCIA MULTIPLA') 
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS DISEASECLASSIFICATION (
	ID INTEGER,
	CID CHAR(5),
	DESCRIPTION VARCHAR(100),
	
    CONSTRAINT PK_DISEASECLASSIFICATION__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_DISEASECLASSIFICATION__CID UNIQUE (CID),
    CONSTRAINT NN_DISEASECLASSIFICATION__CID CHECK (CID IS NOT NULL),
    CONSTRAINT NN_DISEASECLASSIFICATION__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_DISEASECLASSIFICATION__ID;

ALTER SEQUENCE SQ_DISEASECLASSIFICATION__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_DISEASECLASSIFICATION__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_DISEASECLASSIFICATION__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_DISEASECLASSIFICATION__ID
BEFORE INSERT ON DISEASECLASSIFICATION
FOR EACH ROW
EXECUTE FUNCTION BI_DISEASECLASSIFICATION__ID();

CREATE TABLE IF NOT EXISTS CUSTOMER (
	ID INTEGER,
	
	NAMEBIOLOGICAL VARCHAR(150),
	NAMESOCIAL VARCHAR(150),

	ID_BIOLOGICALSEX INTEGER,
	ID_SEXUALORIENTATION INTEGER,
	ID_GENDERIDENTITY INTEGER,
	ID_GENDEREXPRESSION INTEGER,

	BIRTHDATE DATE,

	RG VARCHAR(25),
	CPF VARCHAR(25),

	ID_ETHNICGROUP INTEGER,
	ID_MARITALSTATUS INTEGER,
	ID_RELIGIOUSAFFILIATION INTEGER,
	ID_JOBOCCUPATION INTEGER,
	ID_ACADEMICDEGREE INTEGER,
	ID_MONTHLYINCOME INTEGER,
	ID_MEDICALINSURANCE INTEGER,
	ID_BLOODTYPE INTEGER,
	ID_DISABILITYPERSON INTEGER,
	ID_DISEASECLASSIFICATION INTEGER,

	ID_REGISTRATIONSTATUS INTEGER,

	OBSERVATION VARCHAR(255),

	CONSTRAINT PK_CUSTOMER__ID PRIMARY KEY (ID),
	CONSTRAINT NN_CUSTOMER__NAMEBIOLOGICAL CHECK (NAMEBIOLOGICAL IS NOT NULL),
	CONSTRAINT FK_CUSTOMER_BIOLOGICALSEX__ID FOREIGN KEY (ID_BIOLOGICALSEX) REFERENCES BIOLOGICALSEX(ID),
	CONSTRAINT FK_CUSTOMER_SEXUALORIENTATION__ID FOREIGN KEY (ID_SEXUALORIENTATION) REFERENCES SEXUALORIENTATION(ID),
	CONSTRAINT FK_CUSTOMER_GENDERIDENTITY__ID FOREIGN KEY (ID_GENDERIDENTITY) REFERENCES GENDERIDENTITY(ID),
	CONSTRAINT FK_CUSTOMER_GENDEREXPRESSION__ID FOREIGN KEY (ID_GENDEREXPRESSION) REFERENCES GENDEREXPRESSION(ID),
	CONSTRAINT FK_CUSTOMER_ETHNICGROUP__ID FOREIGN KEY (ID_ETHNICGROUP) REFERENCES ETHNICGROUP(ID),
	CONSTRAINT FK_CUSTOMER_MARITALSTATUS__ID FOREIGN KEY (ID_MARITALSTATUS) REFERENCES MARITALSTATUS(ID),
	CONSTRAINT FK_CUSTOMER_RELIGICOUSAFFILIATION__ID FOREIGN KEY (ID_RELIGIOUSAFFILIATION) REFERENCES RELIGIOUSAFFILIATION(ID),
	CONSTRAINT FK_CUSTOMER_JOBOCCUPATION__ID FOREIGN KEY (ID_JOBOCCUPATION) REFERENCES JOBOCCUPATION(ID),
	CONSTRAINT FK_CUSTOMER_ACADEMICDEGREE__ID FOREIGN KEY (ID_ACADEMICDEGREE) REFERENCES ACADEMICDEGREE(ID),
	CONSTRAINT FK_CUSTOMER_MONTHLYINCOME__ID FOREIGN KEY (ID_MONTHLYINCOME) REFERENCES MONTHLYINCOME(ID),
	CONSTRAINT FK_CUSTOMER_MEDICALINSURANCE__ID FOREIGN KEY (ID_MEDICALINSURANCE) REFERENCES MEDICALINSURANCE(ID),
	CONSTRAINT FK_CUSTOMER_BLOODTYPE__ID FOREIGN KEY (ID_BLOODTYPE) REFERENCES BLOODTYPE(ID),
	CONSTRAINT FK_CUSTOMER_DISABILITYPERSON__ID FOREIGN KEY (ID_DISABILITYPERSON) REFERENCES DISABILITYPERSON(ID),
	CONSTRAINT FK_CUSTOMER_DISEASECLASSIFICATION__ID FOREIGN KEY (ID_DISEASECLASSIFICATION) REFERENCES DISEASECLASSIFICATION(ID),
	CONSTRAINT FK_CUSTOMER_REGISTRATIONSTATUS__ID FOREIGN KEY (ID_REGISTRATIONSTATUS) REFERENCES REGISTRATIONSTATUS(ID)
);

CREATE SEQUENCE IF NOT EXISTS SQ_CUSTOMER__ID;

ALTER SEQUENCE SQ_CUSTOMER__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_CUSTOMER__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_CUSTOMER__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_CUSTOMER__ID
BEFORE INSERT ON CUSTOMER
FOR EACH ROW
EXECUTE FUNCTION BI_CUSTOMER__ID();

CREATE TABLE IF NOT EXISTS MOTHERREGISTRY (
	ID INTEGER,
	ID_CUSTOMER INTEGER,
	NAME VARCHAR(150),
	ID_BIOLOGICALSEX INTEGER,
	AGE SMALLINT,
	ID_JOBOCCUPATION INTEGER,
	ID_ACADEMICDEGREE INTEGER,
	OBSERVATION VARCHAR(255)
);

CREATE SEQUENCE IF NOT EXISTS SQ_MOTHERREGISTRY__ID;

ALTER SEQUENCE SQ_MOTHERREGISTRY__ID RESTART WITH 1;

CREATE TABLE IF NOT EXISTS FATHERREGISTRY (
	ID INTEGER,
	ID_CUSTOMER INTEGER,
	NAME VARCHAR(150),
	ID_BIOLOGICALSEX INTEGER,
	AGE SMALLINT,
	ID_JOBOCCUPATION INTEGER,
	ID_ACADEMICDEGREE INTEGER,
	OBSERVATION VARCHAR(255)
);

CREATE SEQUENCE IF NOT EXISTS SQ_FATHERREGISTRY__ID;

ALTER SEQUENCE SQ_FATHERREGISTRY__ID RESTART WITH 1;

CREATE TABLE IF NOT EXISTS BROTHERREGISTRY (
	ID INTEGER,
	ID_CUSTOMER INTEGER,
	NAME VARCHAR(150),
	ID_BIOLOGICALSEX INTEGER,
	AGE SMALLINT,
	ID_JOBOCCUPATION INTEGER,
	ID_ACADEMICDEGREE INTEGER,
	OBSERVATION VARCHAR(255)
);

CREATE SEQUENCE IF NOT EXISTS SQ_BROTHERREGISTRY__ID;

ALTER SEQUENCE SQ_BROTHERREGISTRY__ID RESTART WITH 1;

CREATE TABLE IF NOT EXISTS PARTNERREGISTRY (
	ID INTEGER,
	ID_CUSTOMER INTEGER,
	NAME VARCHAR(150),
	ID_BIOLOGICALSEX INTEGER,
	AGE SMALLINT,
	ID_JOBOCCUPATION INTEGER,
	ID_ACADEMICDEGREE INTEGER,
	OBSERVATION VARCHAR(255)
);

CREATE SEQUENCE IF NOT EXISTS SQ_PARTNERREGISTRY__ID;

ALTER SEQUENCE SQ_PARTNERREGISTRY__ID RESTART WITH 1;

CREATE TABLE IF NOT EXISTS CHILDRENREGISTRY (
	ID INTEGER,
	ID_CUSTOMER INTEGER,
	NAME VARCHAR(150),
	ID_BIOLOGICALSEX INTEGER,
	AGE SMALLINT,
	ID_JOBOCCUPATION INTEGER,
	ID_ACADEMICDEGREE INTEGER,
	OBSERVATION VARCHAR(255)
);

CREATE SEQUENCE IF NOT EXISTS SQ_CHILDRENREGISTRY__ID;

ALTER SEQUENCE SQ_CHILDRENREGISTRY__ID RESTART WITH 1;

CREATE TABLE IF NOT EXISTS USEFREQUENCY (
    ID INTEGER,
    DESCRIPTION VARCHAR(75),

    CONSTRAINT PK_USEFREQUENCY__ID PRIMARY KEY (ID),
    CONSTRAINT UQ_USEFREQUENCY__DESCRIPTION UNIQUE (DESCRIPTION),
    CONSTRAINT NN_USEFREQUENCY__DESCRIPTION CHECK (DESCRIPTION IS NOT NULL)
);

CREATE SEQUENCE IF NOT EXISTS SQ_USEFREQUENCY__ID;

ALTER SEQUENCE SQ_USEFREQUENCY__ID RESTART WITH 1;

CREATE OR REPLACE FUNCTION BI_USEFREQUENCY__ID()
RETURNS TRIGGER AS
$$
BEGIN
  IF NEW.ID IS NULL THEN
    NEW.ID := NEXTVAL('SQ_USEFREQUENCY__ID');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER BI_USEFREQUENCY__ID
BEFORE INSERT ON USEFREQUENCY
FOR EACH ROW
EXECUTE FUNCTION BI_USEFREQUENCY__ID();

INSERT INTO USEFREQUENCY (DESCRIPTION) VALUES ('NUNCA')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO USEFREQUENCY (DESCRIPTION) VALUES ('UMA VEZ')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO USEFREQUENCY (DESCRIPTION) VALUES ('RARAMENTE')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO USEFREQUENCY (DESCRIPTION) VALUES ('FREQUENTEMENTE E PRETENDO PARAR')
ON CONFLICT (DESCRIPTION) DO NOTHING;
INSERT INTO USEFREQUENCY (DESCRIPTION) VALUES ('FREQUENTEMENTE E NAO PRETENDO PARAR')
ON CONFLICT (DESCRIPTION) DO NOTHING;

CREATE TABLE IF NOT EXISTS DRUGADDICTION (
    ID INTEGER,
    ID_CUSTOMER INTEGER,
    ALCOHOL INTEGER,
    TOBACCO INTEGER,
    MARIHUANA INTEGER,
    ECSTASY INTEGER,
    LSD INTEGER,
    COCAINE INTEGER,
    CRACK INTEGER,
    HEROIN INTEGER,
    OPIUM INTEGER,
    AMPHETAMINE INTEGER,
    OBSERVATION VARCHAR(255),
	
	CONSTRAINT PK_DRUGADDICTION__ID PRIMARY KEY (ID),
	CONSTRAINT UQ_DRUGADDICTION__ID_CUSTOMER UNIQUE (ID_CUSTOMER),
	CONSTRAINT NN_DRUGADDICTION__ID_CUSTOMER CHECK (ID_CUSTOMER IS NOT NULL),
	CONSTRAINT FK_DRUGADDICTION_CUSTOMER__ID FOREIGN KEY (ID_CUSTOMER) REFERENCES CUSTOMER(ID),

	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__ALCOHOL FOREIGN KEY (ALCOHOL) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__TOBACCO FOREIGN KEY (TOBACCO) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__MARIHUANA FOREIGN KEY (MARIHUANA) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__ECSTASY FOREIGN KEY (ECSTASY) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__LSD FOREIGN KEY (LSD) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__COCAINE FOREIGN KEY (COCAINE) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__CRACK FOREIGN KEY (CRACK) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__HEROIN FOREIGN KEY (HEROIN) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__OPIUM FOREIGN KEY (OPIUM) REFERENCES USEFREQUENCY(ID),
	CONSTRAINT FK_DRUGADDICTION_USEFREQUENCY__AMPHETAMINE FOREIGN KEY (AMPHETAMINE) REFERENCES USEFREQUENCY(ID)
);

CREATE SEQUENCE IF NOT EXISTS SQ_DRUGADDICTION__ID;

ALTER SEQUENCE SQ_DRUGADDICTION__ID RESTART WITH 1;
